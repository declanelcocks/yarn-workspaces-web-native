/**
 * Project Configuration.
 *
 * NOTE: All file/folder paths should be relative to the project root. The
 * absolute paths should be resolved during runtime by our build internal/server.
 */
import * as EnvVars from './utils/envVars'

const values = {
  // The configuration values that should be exposed to our client bundle.
  // These values will get passed through `/shared/utils/objects/filterWithRules`,
  // then serialized and included in our client bundle
  clientConfigFilter: {
    welcomeMessage: true,
    serviceWorker: {
      enabled: true,
    },
    polyfillIO: true,
    htmlPage: true,
    apiUrl: true,
  },

  // Server host
  host: EnvVars.string('HOST', 'localhost'),

  // Server port
  port: EnvVars.number('PORT', 1337),

  // Default URL to use when making API requests
  apiUrl: EnvVars.string('API_URL', 'http://localhost:3000/api'),

  // Client bundle development server port
  clientDevServerPort: EnvVars.number('CLIENT_DEV_PORT', 7331),

  // This is an example environment variable which is used within the react
  // application to demonstrate the usage of environment variables across
  // the client and server bundles.
  welcomeMessage: EnvVars.string('WELCOME_MSG', 'Hello world!'),

  // Disable server side rendering?
  disableSSR: false,

  // How long should we set the browser cache for the served assets?
  // Changed files will still be served to the browser as we add hashes to each of
  // our files depending on the contents of the file.
  browserCacheMaxAge: '365d',

  // We use the polyfill.io service which provides the polyfills that a
  // client needs, which is far more optimal than the large output
  // generated by babel-polyfill.
  // Note: we have to keep this seperate from our "htmlPage" configuration
  // as the polyfill needs to be loaded BEFORE any of our other javascript
  // gets parsed.
  polyfillIO: {
    enabled: true,
    url: '//cdn.polyfill.io/v2/polyfill.min.js',
    // Reference https://qa.polyfill.io/v2/docs/features for a full list
    // of features.
    features: [
      // The default list.
      'default',
      'es6',
    ],
  },

  // Basic configuration for the HTML page that hosts our application.
  // We make use of react-helmet to consume the values below.
  htmlPage: {
    titleTemplate: 'React, Universally - %s',
    defaultTitle: 'React, Universally',
    description:
      'A starter kit giving you the minimum requirements for a production ready universal react application.',
  },

  // Content Security Policy (CSP)
  // @see server/middleware/security for more info.
  cspExtensions: {
    childSrc: [],
    connectSrc: [],
    defaultSrc: [],
    fontSrc: ['fonts.googleapis.com/css', 'fonts.gstatic.com'],
    imgSrc: [],
    mediaSrc: [],
    manifestSrc: [],
    objectSrc: [],
    scriptSrc: [
      // Allow scripts from cdn.polyfill.io
      'cdn.polyfill.io',
    ],
    styleSrc: [
      'cdn.rawgit.com/milligram/milligram/master/dist/milligram.min.css',
      'fonts.googleapis.com/css',
    ],
  },

  // Public assets folder served from the root of the HTTP server
  publicAssetsPath: './public',

  // Build output folder?
  buildOutputPath: './build',

  // Include source maps for optimised builds of the client bundle?
  includeSourceMapsForOptimisedClientBundle: false,

  // These extensions are tried when resolving src files for our bundles..
  bundleSrcTypes: ['js', 'jsx', 'json'],

  // What should we name the json output file that webpack generates
  // containing details of all output files for a bundle?
  bundleAssetsFileName: 'assets.json',

  // node_modules are not included in any bundles that target "node" as a
  // runtime (e.g.. the server bundle) as including them often breaks builds
  // due to thinks like require statements containing expressions..
  // However. some of the modules contain files need to be processed by
  // one of our Webpack loaders (e.g. CSS). Add any file types to the list
  // below to allow them to be processed by Webpack.
  nodeExternalsFileTypeWhitelist: [
    /\.(eot|woff|woff2|ttf|otf)$/,
    /\.(svg|png|jpg|jpeg|gif|ico)$/,
    /\.(mp4|mp3|ogg|swf|webp)$/,
    /\.(css|scss|sass|sss|less)$/,
  ],

  // The SW includes the "client" bundle assets, as well as the public folder assets,
  // and it is served by the "server" bundle.
  serviceWorker: {
    enabled: true,
    // SW name
    fileName: 'sw.js',
    // Paths to public assets to be included by the SW. Accepts glob syntax.
    includePublicAssets: [
      // NOTE: This will include ALL of our public folder assets.
      './**/*',
    ],
    // Offline page file name
    offlinePageFileName: 'offline.html',
  },

  bundles: {
    client: {
      // Src entry file
      srcEntryFile: './client/index.js',

      // Src paths
      srcPaths: [
        './client',
        './shared',
        // The service worker will have access to the config folder, but due
        // to the environment checks, it won't have access to any values it
        // shouldn't be seeing
        './config',
      ],

      // Client bundle output folder?
      outputPath: './build/client',

      // Public http path we serve the bundle from?
      webPath: '/client/',

      // Create a DLL bundle to improve dev experience. This will decrease the number
      // of modules that Webpack needs to process for every rebuild.
      devVendorDLL: {
        // Enabled?
        enabled: true,

        // Ddependencies to include in the Vendor DLL.
        include: [
          'react',
          'react-dom',
          'react-helmet',
          'react-router-dom',
          'react-router-config',
          'styled-components',
          'styled-tools',
          'styled-theme',
          'redux',
          'react-redux',
          'redux-thunk',
          'isomorphic-fetch',
          'react-modal',
        ],

        // Vendor DLL name
        name: '__dev_vendor_dll__',
      },
    },

    server: {
      // Src entry file
      srcEntryFile: './server/index.js',

      // Src paths
      srcPaths: ['./server', './shared', './config'],

      // Server bundle output folder
      outputPath: './build/server',
    },
  },

  additionalNodeBundles: {
    // NOTE: The webpack configuration and build scripts have been built so
    // that you can add arbitrary additional node bundle configurations here.
    //
    // A common requirement for larger projects is to add additional "node"
    // target bundles (e.g an APi server endpoint). Therefore flexibility has been
    // baked into our webpack config factory to allow for this.
    //
    // Simply define additional configurations similar to below.  The development
    // server will manage starting them up for you.  The only requirement is that
    // within the entry for each bundle you create and return the "express"
    // listener.
    /*
    apiServer: {
      srcEntryFile: './api/index.js',
      srcPaths: [
        './api',
        './shared',
        './config',
      ],
      outputPath: './build/api',
    }
    */
  },

  // These plugin definitions provide a centralised place for config settings
  // without having to reach into the internals of each tool. This also helps
  // with any future changes as all configurations are stored in one place.
  plugins: {
    // This plugin allows you to provide final adjustments your babel
    // configurations for each bundle before they get processed.
    //
    // This function will be called once for each for your bundles.  It will be
    // provided the current webpack config, as well as the buildOptions which
    // detail which bundle and mode is being targetted for the current function run.
    babelConfig: (babelConfig, buildOptions) => {
      // eslint-disable-next-line no-unused-vars
      const { target, mode } = buildOptions

      // Example
      /*
      if (target === 'server' && mode === 'development') {
        babelConfig.presets.push('foo')
      }
     */

      return babelConfig
    },

    // This plugin allows you to provide final adjustments your webpack
    // configurations for each bundle before they get processed.
    //
    // I would recommend looking at the "webpack-merge" module to help you with
    // merging modifications to each config.
    //
    // This function will be called once for each for your bundles.  It will be
    // provided the current webpack config, as well as the buildOptions which
    // detail which bundle and mode is being targetted for the current function run.
    webpackConfig: (webpackConfig, buildOptions) => {
      // eslint-disable-next-line no-unused-vars
      const { target, mode } = buildOptions

      // Example:
      /*
      if (target === 'server' && mode === 'development') {
        webpackConfig.plugins.push(new MyCoolWebpackPlugin())
      }
      */

      // Debugging/Logging Example:
      /*
      if (target === 'server') {
        console.log(JSON.stringify(webpackConfig, null, 4))
      }
      */

      return webpackConfig
    },
  },
}

// This protects us from accidentally including this configuration in our
// client bundle. That would be a big NO NO to do. :)
if (process.env.BUILD_FLAG_IS_CLIENT === 'true') {
  throw new Error(
    "You shouldn't be importing the `<projectroot>/config/values.js` directly into code that will be included in your 'client' bundle as the configuration object will be sent to user's browsers. This could be a security risk! Instead, use the `config` helper function located at `<projectroot>/config/index.js`.",
  )
}

export default values
